Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
Example 3:

Input: nums = [1,0,1,2]
Output: 3
 

Constraints:

0 <= nums.length <= 105
-109 <= nums[i] <= 109

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Is question ko O(n) time complexity me solve karne ke liye hume aisa data structure chahiye jo kisi element ko O(1) time me search kar sake. Iske liye HashSet ya HashMap best option 
hote hain. Lekin yahan hume sirf ye check karna hai ki koi element present hai ya nahi, isliye HashSet ka use karna zyada simple aur effective hai.

Sabse pehle hum array ke saare elements HashSet me store kar dete hain. Isse do fayde hote hain:
pehla, saare elements unique ho jaate hain, aur dusra, kisi bhi element ko O(1) time me check kar sakte hain.

Ab hume HashSet par loop chalana hai. Ye baat sahi hai ki HashSet unordered hota hai, lekin yahan order matter nahi karta, kyunki hume sirf longest consecutive sequence ki length 
nikalni hai, sequence print nahi karni.

Ab question ye aata hai ki hum sequence kahan se start karein â€” smaller se bigger ya bigger se smaller. Agar hum bigger element se start karein, to problem ho sakti hai. Jaise agar
sequence [1,2,3,4,5] hai aur pehle 5 mil gaya, to hum 4,3,2,1 check karenge. Ye dikhne me sahi lagta hai, lekin agar baad me 4 bhi mil gaya, to hum phir se 3,2,1 check karenge. 
Is tarah same kaam baar-baar hoga, jo time complexity badha dega aur TLE ka reason ban sakta hai.

Isliye best approach ye hai ki hum sirf wahi se sequence start karein jiska koi smaller element exist hi na karta ho. Matlab agar current element x hai, to hum pehle check karenge 
ki (x - 1) HashSet me present hai ya nahi. Agar present hai, to iska matlab ye element kisi existing sequence ka beech ka part hai, isliye hum isse skip kar denge. Lekin agar (x - 1)
present nahi hai, to ye element sequence ka starting point hoga. Ab hum x + 1, x + 2, x + 3... check karte jaayenge jab tak elements milte rahein, aur saath-saath count badhate jaayenge.

Is approach se har element sirf ek baar process hota hai, aur isliye overall time complexity O(n) rehti hai.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class Solution {
    public int longestConsecutive(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        int ans = 0;

        for (int a : nums) {
            set.add(a);
        }

        for (int b : set) {   
            if (!set.contains(b - 1)) {
                int current = b;
                int temp = 1;

                while (set.contains(current + 1)) {
                    current++;
                    temp++;
                }

                ans = Math.max(ans, temp);
            }
        }

        return ans;
    }
}
